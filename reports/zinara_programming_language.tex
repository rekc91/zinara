\documentclass[12pt, spanish]{report}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\renewcommand{\baselinestretch}{1.3}
\usepackage{graphicx}

\begin{document}
\title{Universidad Simón Bolívar \\ Lenguajes de Programaci\'on II \\ Zinara}
\author{
  Daniel Barreto - \#04-36723 \texttt{<daniel.barreto.n@gmail.com>} \\
  Germán Jaber - \#06-39743 \texttt{<german@ac.labf.usb.ve>}
}
\maketitle

\tableofcontents

\newpage

\chapter{Introducci\'on}
\label{chap:intr}



\chapter{Dise\~no del Lenguaje}
\label{chap:diseno}


\section{Filosofía y paradigma de programaci\'on}
\label{sec:filpar}


\section{Dise\~no de Tipos}
\label{sec:tipos}

\subsection{Tipos b\'asicos}
\label{sec:tiposbasicos}
Los tipos b\'asicos del lenguaje son:
\begin{itemize}
\item Entero   (Int)
\item Flotante (Float)
\item Booleano (Bool)
\item Char     (Char)
\end{itemize}
Nos pareci\'o que estos eran los \'unicos tipos b\'asicos necesarios
para que el lenguaje fuera \'util e interesante.//
Aunque sean tipos b\'asicos, estos se manejar\'an por referencia,
tal como el resto de los tipos del lenguaje. Esto para mantener
el lenguaje lo m\'as consistente posible.

\section{Sintaxis y Sem\'antica}
\label{sec:synsem}

\subsection{Declaraciones}
\label{sec:decl}

\subsection{Instrucciones}
\label{sec:instr}

\section{Sintaxis y Sem\'antica}
\label{sec:synsem}

Como se mencion\'o anteriormente, \emph{\textbf{Zinara}} trata de ser un
lenguaje que sea facilmente le\'ible, por lo tanto su sintaxis est\'a
pensada para ser simple y minimalista, buscando tener la menor
cantidad de adornos posibles, a diferencia de los lenguajes de
programaci\'on tradicionales\footnote{C/C++, Java, Pascal, entre otros}
que cuentan con una gran cantidad de signos de puntuaci\'on como
delimitadores de instrucciones o declaraciones.\\

Para conseguir este objetivo se tomaron las siguientes decisiones en
cuanto a la sintaxis del lenguaje:

\begin{itemize}
\item Las instrucciones de un programa estar\'an delimitadas por un
 salto de l\'inea, sin alg\'un tipo de signo de puntuaci\'on divisorio.

\item Los bloques de c\'odigo (que ser\'an detallados m\'as adelante)
 estar\'an delimitados \'unicamente por una palabra clave que represente
 dicho bloque, condiciones extras si son requeridas, y la palabra
 clave de finalizaci\'on de bloque de c\'odigo: ``end''.

\item Cuando sea posible y tenga sentido hacerlo, se dar\'a preferencia
 a usar palabras del idioma ingl\'es como palabras clave en donde los
 lenguajes de programaci\'on tradicionales utilizan signos de
 puntuaci\'on.
\end{itemize}

A continuaci\'on se describe como estan dise\~nadas las partes principales
de la sintaxis del lenguaje. Para facilitar la explicaci\'on se
establecen los siguientes lineamientos:

\begin{itemize}
\item \texttt{<tipo>} representa un tipo cualquiera del lenguaje, entre ellos
 los tipos b\'asicos explicados anteriormente en la secci\'on
 \ref{sec:tiposbasicos}.

\item \texttt{<identificador>}, \texttt{id1}, \texttt{id2},
 \texttt{idN} representan identificadores del lenguaje, cualquier
 palabra que empiece on una letra min\'uscula o may\'uscula de la ``a'' a
 la ``z'', seguido por cualquier cantidad de letras, n\'umeros o
 comillas simples \'.

\item \texttt{<expresion>}, \texttt{expr1}, \texttt{expr2},
 \texttt{exprN} representan expresiones cualquiera del lenguaje, como
 son explicadas en la secci\'on \ref{sec:expr}.

\item \texttt{<code_block>}, \texttt{<code_block1>}, \texttt{<code_block2>},
      \texttt{<code_blockn>} representan secuencias de instrucciones y
      estructuras de control del lenguaje.

\item Cualquier palabra o secuencia de palabras delimitadas entre
 \texttt{[} y \texttt{]} es opcional.

\item Un conjunto de palabras separadas por \texttt{|} idica que una y
solo una de las palabras del conjunto puede aparecer en ese punto.
\end{itemize}

\subsection{Instrucciones}
Las instrucciones del lenguaje que no estan exclusivamente
ligadas a alg\'un tipo compuesto son:
\begin{itemize}
\item Secuenciaci\'on
\item Asignaci\'on
\item Declaraci\'on de constantes
\item Declaraci\'on de variables
\item Declaraci\'on de funci\'on
\item Return
\item Invocaci\'on de funci\'on
\item Impresi\'on
\end{itemize}

\subsubsection{Secuenciaci\'on}
Se secuenci\'an varias instrucciones separandolas con saltos
de l\'inea. No importa que la \'ultima instrucci\'on tenga
tambi\'en un salto de l\'inea.

\subsubsection{Asignaci\'on}
Sintaxis:
Las asignaciones se pueden realizar de dos formas:\\

\textbf{Una a la vez}:
\begin{verbatim}
<identificador> [= <expresion>]
\end{verbatim}

\begin{verbatim}
<id1>, <id2>, ..., <idN> [= <expr1>, <expr2>, ..., <exprN>]
\end{verbatim}

\subsection{Declaraciones}
\label{sec:decl}
Sintaxis:
Las declaraciones se pueden realizar de dos formas:\\

\textbf{Una a la vez}:
\begin{verbatim}
[var] <tipo> <identificador> [= <expresion>]
\end{verbatim}

\textbf{o de forma m\'ultiple}:
\begin{verbatim}
[var] <tipo> <id1>, <id2>, ..., <idN> [= <expr1>, <expr2>, ..., <exprN>]
\end{verbatim}

La palabra clave \texttt{var} denota si el identificador, o los
indentificadores, que estan siendo declarados se comportar\'an como
variables en el lenguaje de programaci\'on. Si \texttt{var} se omite, el
identificador (o identificadores) ser\'a declarado como constante, y una
vez que le sea asignado un valor de una expresi\'on, \'este ser\'a
inmutable.

Existe un tercer tipo de declaraci\'on: \emph{Declaraci\'on de funcion},
el cual es explicado en la secci\'on \ref{sec:func}.

\subsubsection{Declaraci\'on de funci\'on}
\label{sec:func}
Sintaxis:\\
\begin{verbatim}
<id> ([copy] <id1> as <type> , [copy] <id2> as <type> , ... , [copy] <idn> as <type>) returns <type> :
   <code_block>
end|enddef
\end{verbatim}

\texttt{copy} es el nombre que tendra la funci\'on,
\texttt{id1}, \texttt{id2} ... \texttt{idn} son los nombre de los
par\'ametros formales.

Las funciones pasan todo por referencia a menos que se indique
expl\'icitamente que el pasaje debe hacerse por valor con la palabra
reservada \texttt{copy}.

\subsubsection{Return}
\label{sec:return}
Sintaxis:\\
\begin{verbatim}
return <expr>
\end{verbatim}

Esta instrucci\'on solo puede ser usada dentro de una funci\'on. Lo que
hace es detener el flujo de la funci\'on y hacer que esta devuelva \texttt{expr}.

\subsubsection{Invocaci\'on de funci\'on}
\label{sec:inv}
Sintaxis:\\
\begin{verbatim}
<id> (<expr1> , <expr2> , ... , <exprn>)
\end{verbatim}

Las invocaciones a funciones pueden ser tanto instrucciones como
expresiones.

\subsubsection{Impresi\'on}
Sintaxis:
\begin{verbatim}
print ( <expr> )
\end{verbatim}

Imprime la expresion entre par\'entesis a la salida est\'andar. \texttt{expr}
puede tener cualquier tipo del lenguaje, pero no un tipo definido por el usuario.

\subsection{Operadores}
\label{sec:ops}

\subsubsection{Operadores Aritm\'eticos}
\begin{itemize}
\item Suma     (+)
\item Resta    (-)
\item Producto (*)
\item Divisi\'on  (/)
\item M\'odulo (\%)
\item Potencia (\^)
\item Menos unario (-)
\end{itemize}

\subsubsection{Operadores Relacionales}
\begin{itemize}
\item Mayor         (>)
\item Menor         (<)
\item Mayor o igual (>=)
\item Menor o igual (<=)
\item Igual (superficial) (==)
\item Igual (profundo)    (<=>)
\item Negaci\'on      (!)
\end{itemize}

\subsubsection{Operadores L\'ogicos}
\begin{itemize}
\item And con corto-circuito (AND)
\item And sin corto-circuito (\&)
\item Or con corto-circuito  (OR)
\item Or sin corto-circuito  (|)
\item Diferente              (?)
\end{itemize}

Todos los operadores asocian a la izquierda. Sus precedencias son:
\begin{itemize}
\item AND ,\& , OR , | , ?
\item < , > , <= , >= , == , <=> , !
\item \- (Unario)
\item \^
\item * , / , \%
\item + , - (Binario)
\end{itemize}

\subsubsection{Coherciones}
\\
\begin{tabular}{|c||cccc|}
	\hline
+      &  Int  & Float & Char  & Bool  \\
	\hline \hline
Int    &  Int  & Float & Clash & Clash \\
Float  & Float & Float & Clash & Clash \\
Char   & Clash & Clash & Clash & Clash \\
Bool   & Clash & Clash & Clash & Clash \\
	\hline
\end{tabular}
\\
\begin{tabular}{|c||cccc|}
	\hline
-      &  Int  & Float & Char  & Bool  \\
	\hline \hline
Int    &  Int  & Float & Clash & Clash \\
Float  & Float & Float & Clash & Clash \\
Char   & Clash & Clash & Clash & Clash \\
Bool   & Clash & Clash & Clash & Clash \\
	\hline
\end{tabular}
\\
\begin{tabular}{|c||cccc|}
	\hline
*      &  Int  & Float & Char  & Bool  \\
	\hline \hline
Int    &  Int  & Float & Clash & Clash \\
Float  & Float & Float & Clash & Clash \\
Char   & Clash & Clash & Clash & Clash \\
Bool   & Clash & Clash & Clash & Clash \\
	\hline
\end{tabular}
\\
\begin{tabular}{|c||cccc|}
	\hline
/      &  Int  & Float & Char  & Bool  \\
	\hline \hline
Int    &  Int  & Float & Clash & Clash \\
Float  & Float & Float & Clash & Clash \\
Char   & Clash & Clash & Clash & Clash \\
Bool   & Clash & Clash & Clash & Clash \\
	\hline
\end{tabular}
\\
\begin{tabular}{|c||cccc|}
	\hline
\%     &  Int  & Float & Char  & Bool  \\
	\hline \hline
Int    &  Int  & Float & Clash & Clash \\
Float  & Float & Float & Clash & Clash \\
Char   & Clash & Clash & Clash & Clash \\
Bool   & Clash & Clash & Clash & Clash \\
	\hline
\end{tabular}
\\
\begin{tabular}{|c||cccc|}
	\hline
\^     &  Int  & Float & Char  & Bool  \\
	\hline \hline
Int    &  Int  & Float & Clash & Clash \\
Float  & Float & Float & Clash & Clash \\
Char   & Clash & Clash & Clash & Clash \\
Bool   & Clash & Clash & Clash & Clash \\
	\hline
\end{tabular}
\\
\begin{tabular}{|c||cccc|}
	\hline
<,>,<=,>=&  Int  & Float & Char  & Bool  \\
	\hline \hline
Int      &  Bool &  Bool & Clash & Clash \\
Float    &  Bool &  Bool & Clash & Clash \\
Char     & Clash & Clash & Clash & Clash \\
Bool     & Clash & Clash & Clash & Clash \\
	\hline
\end{tabular}
\\
\begin{tabular}{|c||cccc|}
	    \hline
AND,OR,|,\& &  Int  & Float & Char  & Bool  \\ 
	    \hline \hline
Int         & Clash & Clash & Clash & Clash \\
Float       & Clash & Clash & Clash & Clash \\
Char        & Clash & Clash & Clash & Clash \\
Bool        & Clash & Clash & Clash & Bool \\
	\hline
\end{tabular}


\subsection{Expresiones}
\label{sec:expr}

\subsection{Estructuras de control}
\label{sec:ecntrl}
Tenemos 4 estructuras de control
\begin{itemize}
\item If: para ramificar el flujo del programa
\item While: para ciclos gen\'ericos
\item Cycle: tambi\'en para ciclos gen\'ericos
\item For: para iterar sobre listas y tuplas
\end{itemize}

Revisemos ahora su sintaxis. Note que en este caso, no estaremos
definiendo la sintaxis en forma de gram\'atica, si no de manera m\'as natural.

\subsubsection{If}
Sintaxis:
\begin{verbatim}
   if <expr> :
       <code_block1>
  [elif <expr> :
       <code_block2>]
   .
   .
   .
  [else :
       <code_blockn>]
   end|endif
\end{verbatim}

\subsubsection{While}
Sintaxis:
\begin{verbatim}
   while <expr> :
       <code_block1>
   end|endwhile
\end{verbatim}

\subsubsection{Cycle}
Sintaxis:
\begin{verbatim}
   cycle[:
     code_block]
     [on <expr1> :
          <code_block1>]
     [on <expr2> :
          <code_block2>]
      .
      .
      .
      default :         | on <exprn> :
          <code_blockn> |     <code_blockn>
   end|endcycle
\end{verbatim}
Esta estructura de control iterativa recorrera cada una de las clausulas
\texttt{on} probando el valor de la expresi\'on, tomar\'a la primera que sea cierta
y cuando termine su ejecuci\'on volver\'a a recorrer las clausulas. La
estructura para cuando ninguna clausula se cumple.

\subsubsection{For}
Sintaxis:
\begin{verbatim}
   for <id> in <expr> :
       <code>
   end
\end{verbatim}

Esta estructura esta dise\~nada para recorrer listas y tuplas del
lenguaje, por lo que \texttt{expr} s\'olo puede ser una tupla o lista. El
elemento actual de la iteraci\'on solo se puede accesar a trav\'es del
identificador \texttt{id} dentro del ciclo. Ni el elemento iterado \texttt{expr} ni
el \'indice \texttt{id} pueden ser modificados dentro de la estructura de control.\\

\subsection{Funciones y Procedimientos}
\label{sec:func}

\chapter{Implementaci\'on}
\label{chap:impl}
Utilizamos herramientas de generaci\'on de c\'odigo para crear el lexer y
el parser. Elegimos usar un parser LALR(1) debido a que reconoce m\'as
lenguajes que un parser LL(1) y a que el manejo de precedencias y
asociatividades es mucho mas simple.\\
Creamos el \'arbol sintactico abstracto a medida que se reconoce el
c\'odigo. Para guardar el AST usamos hicimos una jerarqu\'ia
de clases que representan los nodos de inter\'es en el \'arbol. Cada clase
tiene como atributos a otras clases de la jerarqu\'ia, que representan los
elementos de los cuales esta compuesto ese elemento del lenguaje. As\'i,
la clase If, por ejemplo, tiene como atributos un objeto ArrayList que
contiene objetos IfCase, un IfCase tiene como atributos un objeto
Expresion y un objeto CodeBlock.\\
Para guardar las tablas de s\'imbolos se usa una tabla de hash que
guardamos dentro de una clase Symtable y le dimos a esta clase una interfaz
sem\'anticamente m\'as coherente con el manejo de s\'imbolos.
Existen solamente dos tablas de s\'imbolos, sin incluir las tablas de
cada funci\'on. Una tabla es para s\'imbolos globales y otra para
s\'imbolos del programa principal. Fue una decisi\'on de
dise\~no no permitir que los bloques tuvieran sus propias tablas, ya que
consideramos que es propenso a errores.

\section{Herramientas utilizadas}
\label{sec:herramientas}
Para generar el lexer usamos Jflex, un generador de lexers que genera
c\'odigo Java.\\
El parser lo generamos con CUP, un generador de parsers LALR(1) que
tambi\'en genera c\'odigo Java.\\
Ambas herramientas ofrecen muchas funcionalidades para conectarse y
comunicarse entre ellas, esta es la pricipal raz\'on por la cual elegimos
estas dos herramientas en particular.\\
Para simplificar el proceso de compilaci\'on utilizamos ant, una
herramienta de compilaci\'on para Java para compilaci\'on dirigida.\\
Utilizamos git, un manejador de versiones, para ayudarnos en el proceso
colaborativo y para mantener un control consiso de lo que se hiba
haciendo.

\section{Requerimientos para compilar}
\label{sec:requ}
Para compilar es necesario tener la m\'aquina virtual y el compilador de
Java 1.4. Tambi\'en es necesario tener instalado ant.\\
El c\'odigo del lenguaje viene con Jflex y CUP, estas son las versiones
que se bajan directamente de las p\'aginas web de estos proyectos. Se
recomienda que se compile el lenguaje con estas herramientas y se
asegura que funcionar\'a adecuadamente si de hecho se compila de esta
forma. En caso de no poder o no querer utilizar alguna o ambas
herramientas que vienen con el c\'odigo, se necesita tener CUP y/o Jflex
instalado en la m\'aquina donde se correra el parser.\\

\subsection{Pasos para compilar ZINARA}
\label{sec:compilacion}
Para compilar debe generar el parser, generar el lexer y compilar el
c\'odigo con ant. De aqu\'i en adelante asumiremos que <root> representa
la ruta hasta la carpeta donde se encuentra el c\'odigo, incluyendo la
carpeta con el proyecto:

\begin{itemize}
\item Variables de ambiente:\\
\indent Debe incluir en su variable de ambiente CLASSPATH el directorio
\begin{verbatim}
<root>/tools/cup/
\end{verbatim}

\item Generar el parser:\\
\indent El parser se encuentra en:\\
\begin{verbatim}
<root>/project/src/zinara/parser/parser.cup
\end{verbatim}
para generar el parser con el CUP que viene con el proyecto, bajo un ambiente Unix, debe hacer :\\
\begin{verbatim}
java java_cup.Main <root>/project/src/zinara/parser/parser.cup
\end{verbatim}

\item Generar el Lexer:\\
\indent El lexer se encuentra en:\\
\begin{verbatim}
<root>/project/src/zinara/lexer/lexer.flex
\end{verbatim}
para generar el parser con el Jflex que viene con el proyecto, bajo un ambiente Unix, debe hacer :\\
\begin{verbatim}
<root>/tools/jflex/bin/jflex <root>/project/src/zinara/lexer/lexer.jflex
\end{verbatim}

\item Compilaci\'on:\\
\indent Para compilar el proyecto, bajo un ambiente Unix, debe hacer desde <root>/project/:\\
\begin{verbatim}
ant
\end{verbatim}

\item Ejecuci\'on:\\
\indent Para probar un programa, bajo un ambiente Unix, debe hacer desde <root>/project/:\\
\begin{verbatim}
./run.sh Main <path_to_source>
\end{verbatim}
\end{itemize}

\section{El c\'odigo}
\label{sec:codigo}

\subsection{Paquetes}
\label{sec:paquetes}

\subsection{\'Arbol sint\'actico abstracto}
\label{sec:ast}

\subsection{Tabla de s\'imbolos}
\label{sec:st}
Las clases que manejan la tabla de s\'imbolos se encuentran en,
partiendo de la carpeta donde esta guardado el c\'odigo del lenguaje:
\begin{verbatim}
project/src/zinara/ast/Symtable.java\\
project/src/zinara/ast/SymValue.java
\end{verbatim}
\indent Symtable.java es un wrapper para HashTable. Simplemente da
nombres semanticamente mas coherentes con el manejo de s\'imbolos que
los de HashTable. Los pares key/value guardados en la tabla de hash con
del tipo String/SymValue.\\
\indent SymValue.java es un contenedor que guarda un Object, un Type y
un boolean. El Object es el valor del s\'imbolo, el Type simplemente
indica el tipo del objeto y el boolean indica si el s\'imbolo es
variable o no. 

\chapter{Estado actual del lenguaje}
\label{chap:estado}



\end{document}